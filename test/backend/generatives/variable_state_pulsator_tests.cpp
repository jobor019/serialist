#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_floating_point.hpp>

#include "core/generatives/variable_state_pulsator.h"
#include "core/algo/temporal/time_point.h"

TEST_CASE("VariableStatePulsator ctor") {
    VariableStatePulsator p;
}

static VariableStatePulsator init_pulsator(const DomainDuration& duration
                                           , double legato
                                           , VariableStatePulsator::Mode mode
                                           , const TimePoint& time) {
    VariableStatePulsator p;
    p.set_duration(duration);
    p.set_legato_amount(legato);
    p.set_mode(mode);
    p.start(time, std::nullopt);
    return p;
}

const inline double epsilon = 1e-8;

TEST_CASE("VariableStatePulsator: Mode::auto_pulsator") {
    DomainDuration duration(2.0, DomainType::ticks);
    double legato = 1.0;
    auto time = TimePoint::zero();

    VariableStatePulsator p = init_pulsator(duration, legato, VariableStatePulsator::Mode::auto_pulsator, time);
    auto triggers = p.poll(time + epsilon);
    REQUIRE(triggers.size() == 1);
    REQUIRE(Trigger::contains_pulse_on(triggers));


    for (std::size_t i = 1; i < 10; ++i) {
        time += duration.get_value();
        REQUIRE(p.poll(time - epsilon).empty());

        triggers = p.poll(time + epsilon);
        REQUIRE(triggers.size() == 2);
        REQUIRE(Trigger::contains_pulse_on(triggers, i + 1));
        REQUIRE(Trigger::contains_pulse_off(triggers, i));
    }
}

TEST_CASE("VariableStatePulsator: Mode::triggered_pulsator") {
    DomainDuration duration(2.0, DomainType::ticks);
    double legato = 1.0;
    auto time = TimePoint::zero();

    VariableStatePulsator p = init_pulsator(duration, legato, VariableStatePulsator::Mode::triggered_pulsator, time);

    for (std::size_t i = TriggerIds::get_instance().peek_next_id(); i < 10; ++i) {
        auto triggers = p.handle_external_triggers(time, Voice<Trigger>::singular(Trigger::pulse_on()));
        REQUIRE(triggers.size() == 1);
        for (auto t : triggers) {
            std::cout << "trigger " << t.get_id() << std::endl;
        }
        REQUIRE(Trigger::contains_pulse_on(triggers, i));

        REQUIRE(p.poll(time + epsilon).empty());

        time += duration.get_value() * legato;
        REQUIRE(p.poll(time - epsilon).empty());

        triggers = p.poll(time + epsilon);
        REQUIRE(triggers.size() == 1);
        REQUIRE(Trigger::contains_pulse_off(triggers, i));
    }
}

TEST_CASE("VariableStatePulsatorWrapper: triggered_pulsator") {
    VariableStatePulsatorWrapper<double> v;

    double duration = 2.0;
    auto t = TimePoint(0.0);

    auto& trigger_node = v.trigger;
    auto& pulsator = v.pulsator_node;
    auto& duration_node = v.duration;
    auto& enabled_node = v.enabled;

    duration_node.set_values(duration);

    // by default, all nodes are connected => triggered_pulsator
    REQUIRE(pulsator.get_mode() == VariableStatePulsator::Mode::triggered_pulsator);

//    SECTION("Trivial case") {
//        // Add initial trigger/pulse_on
//        trigger_node.set_values(Trigger::pulse_on(id));
//        trigger_node.update_time(t);
//        pulsator.update_time(t);
//        auto triggers = pulsator.process();
//        REQUIRE(triggers.size() == 1);
//        REQUIRE(triggers[0].size() == 1);
//        REQUIRE(Trigger::contains_pulse_on(triggers[0]));
//
//        // Clear trigger, advance time and check that no new trigger is generated by pulsator
//        t.increment(epsilon);
//        trigger_node.set_values(Voices<Trigger>::empty_like());
//        trigger_node.update_time(t);
//        pulsator.update_time(t);
//        REQUIRE(pulsator.process().is_empty_like());
//
//        // Check pulse_off
//        pulsator.update_time(TimePoint(duration - epsilon));
//        REQUIRE(pulsator.process().is_empty_like());
//        pulsator.update_time(TimePoint(duration + epsilon));
//        triggers = pulsator.process();
//        REQUIRE(triggers.size() == 1);
//        REQUIRE(triggers[0].size() == 1);
//        REQUIRE(Trigger::contains_pulse_off(triggers[0], id));
//    }

    SECTION("Enabled/Disabled") {
        enabled_node.set_values(false);
        enabled_node.update_time(t);

        // No output when disabled
        trigger_node.set_values(Trigger::pulse_on());
        trigger_node.update_time(t);
        pulsator.update_time(t);
        REQUIRE(pulsator.process().is_empty_like());

        t.increment(epsilon);
        enabled_node.set_values(true);
        enabled_node.update_time(t);

        // Output when re-enabled
        pulsator.update_time(t);
        auto triggers = pulsator.process();
        REQUIRE(triggers.size() == 1);
        REQUIRE(triggers[0].size() == 1);
        REQUIRE(Trigger::contains_pulse_on(triggers[0]));
    }
}

TEST_CASE("VariableStatePulsatorWrapper: auto_pulsator") {

}

TEST_CASE("VariableStatePulsatorWrapper: auto_pulsator multiple triggers") {
    VariableStatePulsatorWrapper<double> v;

    auto& p = v.pulsator_node;

    // Switch to AutoPulsator
    p.set_trigger(nullptr);

    auto t = TimePoint(0.0);

    // start of initial pulse
    p.update_time(t + epsilon);
    auto triggers = p.process();
    REQUIRE(triggers.size() == 1);
    REQUIRE(triggers[0].size() == 1);
    REQUIRE(Trigger::contains_pulse_on(triggers[0]));

    v.num_voices.set_value(2);

    // same time: new voice should have a pulse_on
    p.update_time(t);
    triggers = p.process();

    REQUIRE(triggers.size() == 2);
    REQUIRE(triggers[0].empty()); // no trigger in first voice as this was already handled
    REQUIRE(triggers[1].size() == 1);
    REQUIRE(Trigger::contains_pulse_on(triggers[1]));
    triggers.print();
}

TEST_CASE("VariableStatePulsatorWrapper: triggered_pulsator multiple triggers") {
    VariableStatePulsatorWrapper<double> v;

    double duration = 2.0;
    v.duration.set_values(duration);
    v.legato_amount.set_values(1.0); // for triggered_pulsator, actual_duration = duration * legato

    auto& p = v.pulsator_node;
    auto& incoming_triggers = v.trigger;

    auto t = TimePoint(0.0);
    incoming_triggers.set_values(Voices<Trigger>::transposed({Trigger::pulse_on(), Trigger::pulse_on()}));
    p.update_time(t);
    auto outgoing_triggers = p.process();
    REQUIRE(outgoing_triggers.size() == 2);
    REQUIRE(outgoing_triggers[0].size() == 1);
    REQUIRE(Trigger::contains_pulse_on(outgoing_triggers[0]));
    REQUIRE(outgoing_triggers[1].size() == 1);
    REQUIRE(Trigger::contains_pulse_on(outgoing_triggers[1]));


    t = TimePoint(duration - epsilon);
    incoming_triggers.set_values(Voices<Trigger>::empty_like());
    p.update_time(t);
    outgoing_triggers = p.process();

    outgoing_triggers.print();
}