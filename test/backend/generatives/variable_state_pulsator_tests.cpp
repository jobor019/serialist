#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_floating_point.hpp>

#include "core/generatives/variable_state_pulsator.h"

TEST_CASE("VariableStatePulsator ctor") {
    VariableStatePulsator p;
}

static VariableStatePulsator init_pulsator(double duration
                                           , double legato
                                           , VariableStatePulsator::Mode mode
                                           , double time) {
    VariableStatePulsator p;
    p.set_duration(duration);
    p.set_legato_amount(legato);
    p.set_mode(mode);
    p.start(time, std::nullopt);
    return p;
}

const inline double epsilon = 1e-8;

TEST_CASE("VariableStatePulsator: Mode::auto_pulsator") {
    double duration = 2.0;
    double legato = 1.0;
    double time = 0.0;

    VariableStatePulsator p = init_pulsator(duration, legato, VariableStatePulsator::Mode::auto_pulsator, time);
    auto triggers = p.poll(time + epsilon);
    REQUIRE(triggers.size() == 1);
    REQUIRE(Trigger::contains_pulse_on(triggers));


    for (std::size_t i = 1; i < 10; ++i) {
        time += duration;
        REQUIRE(p.poll(time - epsilon).empty());

        triggers = p.poll(time + epsilon);
        REQUIRE(triggers.size() == 2);
        REQUIRE(Trigger::contains_pulse_on(triggers, i + 1));
        REQUIRE(Trigger::contains_pulse_off(triggers, i));
    }
}

TEST_CASE("VariableStatePulsator: Mode::triggered_pulsator") {
    double duration = 2.0;
    double legato = 1.0;
    double time = 0.0;

    VariableStatePulsator p = init_pulsator(duration, legato, VariableStatePulsator::Mode::triggered_pulsator, time);

    for (std::size_t i = TriggerIds::get_instance().peek_next_id(); i < 10; ++i) {
        auto triggers = p.handle_external_triggers(time, Voice<Trigger>::singular(Trigger::pulse_on()));
        REQUIRE(triggers.size() == 1);
        for (auto t : triggers) {
            std::cout << "trigger " << t.get_id() << std::endl;
        }
        REQUIRE(Trigger::contains_pulse_on(triggers, i));

        REQUIRE(p.poll(time + epsilon).empty());

        time += duration * legato;
        REQUIRE(p.poll(time - epsilon).empty());

        triggers = p.poll(time + epsilon);
        REQUIRE(triggers.size() == 1);
        REQUIRE(Trigger::contains_pulse_off(triggers, i));
    }
}

TEST_CASE("VariableStatePulsatorWrapper: triggered_pulsator") {
    VariableStatePulsatorWrapper<double> v;

    double duration = 2.0;
    auto t = TimePoint(0.0);

    auto& trigger_node = v.trigger;
    auto& pulsator = v.pulsator_node;
    auto& duration_node = v.duration;
    auto& enabled_node = v.enabled;

    duration_node.set_values(duration);

    // by default, all nodes are connected => triggered_pulsator
    REQUIRE(pulsator.get_mode() == VariableStatePulsator::Mode::triggered_pulsator);

//    SECTION("Trivial case") {
//        // Add initial trigger/pulse_on
//        trigger_node.set_values(Trigger::pulse_on(id));
//        trigger_node.update_time(t);
//        pulsator.update_time(t);
//        auto triggers = pulsator.process();
//        REQUIRE(triggers.size() == 1);
//        REQUIRE(triggers[0].size() == 1);
//        REQUIRE(Trigger::contains_pulse_on(triggers[0]));
//
//        // Clear trigger, advance time and check that no new trigger is generated by pulsator
//        t.increment(epsilon);
//        trigger_node.set_values(Voices<Trigger>::empty_like());
//        trigger_node.update_time(t);
//        pulsator.update_time(t);
//        REQUIRE(pulsator.process().is_empty_like());
//
//        // Check pulse_off
//        pulsator.update_time(TimePoint(duration - epsilon));
//        REQUIRE(pulsator.process().is_empty_like());
//        pulsator.update_time(TimePoint(duration + epsilon));
//        triggers = pulsator.process();
//        REQUIRE(triggers.size() == 1);
//        REQUIRE(triggers[0].size() == 1);
//        REQUIRE(Trigger::contains_pulse_off(triggers[0], id));
//    }

    SECTION("Enabled/Disabled") {
        enabled_node.set_values(false);
        enabled_node.update_time(t);

        // No output when disabled
        trigger_node.set_values(Trigger::pulse_on());
        trigger_node.update_time(t);
        pulsator.update_time(t);
        REQUIRE(pulsator.process().is_empty_like());

        t.increment(epsilon);
        enabled_node.set_values(true);
        enabled_node.update_time(t);

        // Output when re-enabled
        pulsator.update_time(t);
        auto triggers = pulsator.process();
        REQUIRE(triggers.size() == 1);
        REQUIRE(triggers[0].size() == 1);
        REQUIRE(Trigger::contains_pulse_on(triggers[0]));
    }
}

TEST_CASE("VariableStatePulsatorWrapper: auto_pulsator") {

}
